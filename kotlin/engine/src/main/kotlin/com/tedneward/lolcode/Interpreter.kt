/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package com.tedneward.lolcode

import java.util.Stack
import java.io.BufferedInputStream

import com.tedneward.lolcode.ast.*

// ====================================
// Interpreter
class Frame(val initial : Map<String, Variant> = mapOf(), 
            val enclosing : Frame? = null) {
    val table : MutableMap<String,Variant> = mutableMapOf()

    init {
        initial.forEach { entry -> table.put(entry.key, entry.value) }
    }

    fun peek(name : String) : Boolean {
        if (table.containsKey(name))
            return true
        else if (enclosing != null) 
            return enclosing.peek(name)
        else
            return false
    }
    fun put(name : String, value : Variant) { 
        table.put(name, value)
    }
    fun get(name : String) : Variant { 
        return if (table.get(name) != null) table.get(name)!! else enclosing?.get(name)!!
    }
    override fun toString() : String {
        return "[enclosing:${enclosing?.toString()} ${table.toString()}]"
    }
}

class Interpreter {
    var program : Program = Program()
    var ioOut : java.io.PrintStream = System.out
    var ioIn : java.io.InputStream = System.`in`

    // Our declared functions
    //
    // TODO: Explore storing functions in the stack, which means the stack
    // needs to be refactored to be a <String, Variant|FuncDecl> or Variants
    // need to be able to store FuncDecls or... something
    val functions : MutableMap<String, FuncDecl> = mutableMapOf()

    // Our stack frame management
    //
    val stack = Stack<Frame>()
    fun pushScope() {
        val newFrame = Frame(mapOf(), if (stack.size != 0) stack.peek() else null)
        stack.push(newFrame)
    }
    fun pushScope(initial : Map<String,Variant>) {
        val newFrame = Frame(initial, if (stack.size != 0) stack.peek() else null)
        stack.push(newFrame)
    }
    fun lookup(name : String) : Variant {
        return if (stack.peek().peek(name))
            stack.peek().get(name)
        else
            throw Exception("NUTHIN THERE CALT ${name}");
    }
    fun store(name : String, value : Variant) {
        stack.peek().put(name, value)
    }

    // Version check
    //
    fun version() : String { return "0.1" }

    // Run, interpreter, run
    //
    fun execute(code : String) {
        val programASTNode = ASTVisitor.parseToAST(code)
        run(programASTNode)
    }

    fun run(program : Program) {
        this.program = program
        evaluate(this.program.codeBlock)
    }

    fun evaluate(codeBlock : CodeBlock) : Variant {
        pushScope()

        //locals.forEach { store(it.key, it.value) }

        for (stmt in codeBlock.statements) {
            evaluate(stmt)

            // TODO: 'GTFO' is immediate return NOOB
            // TODO: 'FOUND YR {name}' is a return-with-value
        }

        // If no explicit return is set, return the value of the local "IT"
        return Variant(null)
    }

    fun evaluate(stmt : Statement) {
        when (stmt) {
            is Declaration -> {
                store(stmt.name, evaluate(stmt.expr))
            }
            is Print -> {
                var message = stmt.expressions.joinToString(prefix="", postfix="", separator="") { 
                    evaluate(it).asString()
                }
                ioOut.println(message)
            }
            is Input -> {
                var input = ioIn.bufferedReader().readLine()
                store(stmt.label, Variant(input))
            }
            is Assignment -> {
                store(stmt.label, evaluate(stmt.expr))
            }
            is Expression -> {
                evaluate(stmt)
            }
            is Loop -> {
                while (evaluate(stmt.conditional).asBoolean()) {
                    evaluate(stmt.codeBlock)
                }
            }
            is Conditional -> {
                if (evaluate(stmt.conditional).asBoolean()) {
                    evaluate(stmt.codeBlock)
                }
                else if (stmt.elseBlock != null) {
                    evaluate(stmt.elseBlock as CodeBlock)
                }
            }
            is FuncDecl -> {
                // TODO: Sanity-check for duplication
                // ... or, just go with last definition wins and call it a day

                functions.put(stmt.name, stmt)
            }
        }
    }

    fun evaluate(expr : Expression) : Variant {
        return when (expr) {
            Atom.NOOB -> Variant()
            is Atom -> Variant(expr.value)
            is Label -> lookup(expr.name)
            is BinaryOp -> {
                val left = evaluate(expr.left)
                val right = evaluate(expr.right)
                val opInt : (Long, Long) -> Long = when (expr.op.name) {
                    "ADD" -> { l, r -> l + r }
                    "SUB" -> { l, r -> l - r }
                    "MUL" -> { l, r -> l * r }
                    "DIV" -> { l, r -> l / r }
                    "MOD" -> { l, r -> l % r }
                    else -> throw Exception("Implementation error: Unrecognized operator: ${expr.op}")
                }
                val opDbl : (Double, Double) -> Double = when (expr.op.name) {
                    "ADD" -> { l, r -> l + r }
                    "SUB" -> { l, r -> l - r }
                    "MUL" -> { l, r -> l * r }
                    "DIV" -> { l, r -> l / r }
                    "MOD" -> { l, r -> l % r }
                    else -> throw Exception("Implementation error: Unrecognized operator: ${expr.op}")
                }

                return if (left.isNumbr() && right.isNumbr()) 
                        Variant(opInt(left.asInt64(), right.asInt64()))
                    else if (left.isNumbar() || right.isNumbar())
                        Variant(opDbl(left.asDouble(), right.asDouble())) 
                    else if (left.isYarn() || right.isYarn() && 
                        left.canConvertNumbr() && right.canConvertNumbr())
                        Variant(opInt(left.asInt64(), right.asInt64()))
                    else if (left.isYarn() || right.isYarn() &&
                        left.canConvertNumbar() && right.canConvertNumbar())
                        Variant(opDbl(left.asDouble(), right.asDouble())) 
                    else
                        throw Exception("CANT MATH ON WHATEVR")
            }
            is Comparison -> {
                val left = evaluate(expr.left)
                val right = evaluate(expr.right)
                return Variant(when (expr.op.name) {
                    "EQU" -> left.equals(right)
                    "NEQ" -> ! (left.equals(right))
                    "GT" -> left.greaterThan(right)
                    "LT" -> left.lesserThan(right)
                    "GTE" -> ! (left.lesserThan(right))
                    "LTE" -> ! (left.greaterThan(right))
                    else -> throw Exception("Implementation error: Unrecognized operator: ${expr.op}")
                })
            }
            is UnaryOp -> {
                val result = evaluate(expr.expression)
                return result.not()
            }
            is Logical ->
                when (expr.op) {
                    Logical.Operator.ALL -> {
                        for (e in expr.expressions) {
                            val result = evaluate(e)
                            if (result.asBoolean() == false) {
                                return Variant(false)
                            }
                        }
                        return Variant(true)
                    }
                    Logical.Operator.ANY -> {
                        for (e in expr.expressions) {
                            val result = evaluate(e)
                            if (result.asBoolean() == true) {
                                return Variant(true)
                            }
                        }
                        return Variant(false)
                    }
                    Logical.Operator.AND ->{
                        for (e in expr.expressions) {
                            val result = evaluate(e)
                            if (result.asBoolean() == false) {
                                return Variant(false)
                            }
                        }
                        return Variant(true)
                    }
                    Logical.Operator.OR -> {
                        for (e in expr.expressions) {
                            val result = evaluate(e)
                            if (result.asBoolean() == true) {
                                return Variant(true)
                            }
                        }
                        return Variant(false)
                    }
                    else ->
                        throw Exception("Implementation error: Unrecognized logical: ${expr}")
                }
            is FuncCall -> {
                // Validate we're calling an actual function
                if (functions[expr.name] == null)
                    throw Exception("YR CALL IZ BOGUS: ${expr.name} not defined")

                val func = functions[expr.name]!!

                // Validate that arguments match up with parameters
                val numArgs = expr.arguments.count()
                val numParams = func.parameters.count()
                if (numArgs != numParams)
                    throw Exception("YR CALL IZ BOGUS: ${numParams} expected, ${numArgs} provided")

                // Extract the arguments to the call
                val rawargs : List<Variant> = expr.arguments.map {
                    evaluate(it)
                }
                // Zip them together with the parameter names
                val args : MutableMap<String, Variant> = mutableMapOf()
                for (idx in 0..numParams) {
                    args.put(func.parameters[idx], rawargs[idx])
                }

                // evaluate the code block with the arguments passed in
                evaluate(func.body) //, args)
                return Variant(null)    // return null from all functions for now
            }
            else ->
                throw Exception("Unrecognized expression: ${expr}")
        }
    }
}
