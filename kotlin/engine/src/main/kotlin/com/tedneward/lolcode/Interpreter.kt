/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package com.tedneward.lolcode

import java.util.Stack
import java.io.BufferedInputStream
import org.antlr.v4.runtime.*
import org.antlr.v4.runtime.tree.ParseTree
import org.antlr.v4.runtime.tree.ParseTreeWalker

import com.tedneward.lolcode.ast.*

class ASTBuilder() : lolcodeBaseListener() {
    val program = Program()
    var blockStack = Stack<CodeBlock>()

    override fun enterProgram(ctx : lolcodeParser.ProgramContext) { 
        program.version = if (ctx.opening().version() != null) ctx.opening().version().getText() else "1.2";
    }
    override fun enterCode_block(ctx : lolcodeParser.Code_blockContext) {
        val codeBlock = if (blockStack.isEmpty()) program.codeBlock else CodeBlock()
        blockStack.push(codeBlock)
    }
    override fun exitCode_block(ctx : lolcodeParser.Code_blockContext) {
        blockStack.pop()
    }
    override fun enterDeclaration(ctx : lolcodeParser.DeclarationContext) {
        val decl = Declaration(
            ctx.LABEL().text, 
            if (ctx.expression() != null) 
                ctx.expression().text
            else
                ""
        )
        blockStack.peek().add(decl);
    }
    override fun enterInput_block(ctx : lolcodeParser.Input_blockContext) {
        val input = Input(ctx.LABEL().text)
        blockStack.peek().add(input)
    }
    override fun enterPrint_block(ctx : lolcodeParser.Print_blockContext) {
        val printAST = Print()
        ctx.expression().forEach { it ->
            if (it.ATOM() != null) {
                printAST.add(Atom(it.ATOM().text.replace("\"", "")))
            }
            else if (it.LABEL() != null) {
                printAST.add(Label(it.LABEL().text))
            }
            else {
                throw Exception("Unrecognized node in printAST_block: " + it)
            }
        }
        blockStack.peek().add(printAST)
    }
    override fun enterAssignment(ctx: lolcodeParser.AssignmentContext) {
        // This is wildly inefficient, and I probably need to move to Visitors
        // here before this gets out of hand.
        val label = ctx.LABEL().text
        val expr : Expression = 
            if (ctx.expression().LABEL() != null) {
                Label(ctx.expression().LABEL().text)
            }
            else if (ctx.expression().ATOM() != null) {
                Atom(ctx.expression().ATOM().text.replace("\"", ""))
            }
            else {
                throw Exception("Unrecognized expression")
            }
        val assignment = Assignment(label, expr)
        blockStack.peek().add(assignment)
    }
}

// ====================================
// Interpreter
typealias Scope = MutableMap<String, Variant>

class Interpreter {
    var program : Program = Program()
    var ioOut : java.io.PrintStream = System.out
    var ioIn : java.io.InputStream = System.`in`

    // Our stack frame management
    //
    val stack = Stack<Scope>()
    fun pushScope() {
        stack.push(mutableMapOf())
    }
    fun lookup(name : String) : Variant {
        stack.asReversed().forEach { scope ->
            if (scope.keys.contains(name))
                return scope.get(name)!!
        }
        
        throw Exception("NUTHIN THERE CALT ${name}");
    }
    fun store(name : String, value : Variant) {
        stack.peek().put(name, value)
    }

    // Version check
    //
    fun version() : String { return "0.1" }

    // Run, interpreter, run
    //
    fun execute(code : String) {
        val lexer = lolcodeLexer(CharStreams.fromString(code))
        val tokens = CommonTokenStream(lexer)
        val parser = lolcodeParser(tokens)
        val builder = ASTBuilder()
        ParseTreeWalker.DEFAULT.walk(builder, parser.program())
        run(builder.program)
    }
    fun run(program : Program) {
        this.program = program
        run(this.program.codeBlock)
    }
    fun run(codeBlock : CodeBlock) {
        pushScope()

        fun evaluate(expr : Expression) : Variant {
            return when (expr) {
                is Atom -> Variant(expr.value)
                is Label -> lookup(expr.name)
                is BinaryOp -> {
                    /*
                    Math is performed as integer math in the presence of two NUMBRs, 
                    but if either of the expressions are NUMBARs, 
                    then floating point math takes over.

                    If one or both arguments are a YARN, they get interpreted as NUMBARs
                    if the YARN has a decimal point, and NUMBRs otherwise, then execution 
                    proceeds as above.

                    If one or another of the arguments cannot be safely cast to a numerical 
                    type, then it fails with an error.
                     */
                    val left = evaluate(expr.left)
                    val right = evaluate(expr.right)
                    val opInt : (Long, Long) -> Long = when (expr.op.name) {
                        "ADD" -> { l, r -> l + r }
                        "SUB" -> { l, r -> l - r }
                        "MUL" -> { l, r -> l * r }
                        "DIV" -> { l, r -> l / r }
                        "MOD" -> { l, r -> l % r }
                        else -> throw Exception("Implementation error: Unrecognized operator: ${expr.op}")
                    }
                    val opDbl : (Double, Double) -> Double = when (expr.op.name) {
                        "ADD" -> { l, r -> l + r }
                        "SUB" -> { l, r -> l - r }
                        "MUL" -> { l, r -> l * r }
                        "DIV" -> { l, r -> l / r }
                        "MOD" -> { l, r -> l % r }
                        else -> throw Exception("Implementation error: Unrecognized operator: ${expr.op}")
                    }

                    return if (left.isNumbr() && right.isNumbr()) 
                            Variant(opInt(left.asInt64(), right.asInt64()))
                        else if (left.isNumbar() || right.isNumbar())
                            Variant(opDbl(left.asDouble(), right.asDouble())) 
                        else if (left.isYarn() || right.isYarn() && 
                            left.canConvertNumbr() && right.canConvertNumbr())
                            Variant(opInt(left.asInt64(), right.asInt64()))
                        else if (left.isYarn() || right.isYarn() &&
                            left.canConvertNumbar() && right.canConvertNumbar())
                            Variant(opDbl(left.asDouble(), right.asDouble())) 
                        else
                            throw Exception("CANT MATH ON WHATEVR")
                }
                else ->
                    throw Exception("Unrecognized expression: ${expr}")
            }
        }

        for (node in codeBlock.children) {
            when (node) {
                is Declaration -> {
                    store(node.name, Variant(node.initialValue))
                }
                is Print -> {
                    var message = node.children.joinToString(prefix="", postfix="", separator="") { 
                        // print_blocks can only have expressions,
                        // so this should always be a safe cast
                        evaluate(it as Expression).asString()
                    }
                    ioOut.println(message)
                }
                is Input -> {
                    var input = ioIn.bufferedReader().readLine()
                    store(node.label, Variant(input))
                }
                is Assignment -> {
                    store(node.label, evaluate(node.expression))
                }
                is BinaryOp -> {
                    // This throws away the result--is this a bug?!?
                    evaluate(node)
                }
                else -> {
                    System.out.println("Unrecognized node: ${node}")
                }
            }
        }
    }
}
