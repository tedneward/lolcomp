/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package com.tedneward.lolcode

import java.util.Stack
import java.io.BufferedInputStream
import org.antlr.v4.runtime.*
import org.antlr.v4.runtime.tree.ParseTree
import org.antlr.v4.runtime.tree.ParseTreeWalker

import com.tedneward.lolcode.ast.*

class ASTVisitor() : lolcodeBaseVisitor<Node>() {
    var program = Program()

    override fun visitProgram(ctx: lolcodeParser.ProgramContext) : Node {
        program.version = 
            if (ctx.opening().version() != null) 
                ctx.opening().version().text
            else
                "1.2"

        if (ctx.code_block() != null)
            program.codeBlock = this.visit(ctx.code_block()) as CodeBlock

        return program
    }

	override fun visitCode_block(ctx: lolcodeParser.Code_blockContext) : Node {
        val cb = CodeBlock()
        for (stmt in ctx.statement()) {
            val node = visit(stmt)
            cb.statements.add(node as Statement)
        }
        return cb
    }

	override fun visitDeclaration(ctx: lolcodeParser.DeclarationContext) : Node {
        return Declaration(ctx.LABEL().text, this.visit(ctx.expression()) as Expression)
    }

    override fun visitExpression(ctx: lolcodeParser.ExpressionContext) : Node {
        return if (ctx.ATOM() != null)
            Atom(ctx.ATOM().text.replace("\"", ""))
        else if (ctx.LABEL() != null)
            Label(ctx.LABEL().text)
        else if (ctx.maths() != null)
            this.visit(ctx.maths())
        else
            throw Exception("Somehow expression ${ctx} didn't generate a node")
    }

	override fun visitPrint_block(ctx: lolcodeParser.Print_blockContext) : Node {
        var prnt = Print()

        for (expr in ctx.expression()) {
            val node = visit(expr)
            prnt.expressions.add(node as Expression)
        }

        return prnt
    }

	override fun visitInput_block(ctx: lolcodeParser.Input_blockContext) : Node {
        return Input(ctx.LABEL().text)
    }
    
	override fun visitAssignment(ctx: lolcodeParser.AssignmentContext) : Node {
        return Assignment(ctx.LABEL().text, this.visit(ctx.expression()) as Expression)
    }

    override fun visitMaths(ctx: lolcodeParser.MathsContext) : Node {
        return BinaryOp(
            this.visit(ctx.left) as Expression, 
            BinaryOp.Operator.ADD, 
            this.visit(ctx.right) as Expression)
    }
}

/*
class ASTBuilder() : lolcodeBaseListener() {
    val program = Program()
    var blockStack = Stack<CodeBlock>()

    override fun enterProgram(ctx : lolcodeParser.ProgramContext) { 
        program.version = if (ctx.opening().version() != null) ctx.opening().version().getText() else "1.2";
    }
    override fun enterCode_block(ctx : lolcodeParser.Code_blockContext) {
        val codeBlock = if (blockStack.isEmpty()) program.codeBlock else CodeBlock()
        blockStack.push(codeBlock)
    }
    override fun exitCode_block(ctx : lolcodeParser.Code_blockContext) {
        blockStack.pop()
    }
    override fun enterDeclaration(ctx : lolcodeParser.DeclarationContext) {
        val decl = Declaration(
            ctx.LABEL().text, 
            if (ctx.expression() != null) 
                ctx.expression().text
            else
                ""
        )
        blockStack.peek().add(decl);
    }
    override fun enterInput_block(ctx : lolcodeParser.Input_blockContext) {
        val input = Input(ctx.LABEL().text)
        blockStack.peek().add(input)
    }
    override fun enterPrint_block(ctx : lolcodeParser.Print_blockContext) {
        val printAST = Print()
        ctx.expression().forEach { it ->
            if (it.ATOM() != null) {
                printAST.add(Atom(it.ATOM().text.replace("\"", "")))
            }
            else if (it.LABEL() != null) {
                printAST.add(Label(it.LABEL().text))
            }
            else {
                throw Exception("Unrecognized node in printAST_block: " + it)
            }
        }
        blockStack.peek().add(printAST)
    }
    override fun enterAssignment(ctx: lolcodeParser.AssignmentContext) {
        // This is wildly inefficient, and I probably need to move to Visitors
        // here before this gets out of hand.
        val label = ctx.LABEL().text
        val expr : Expression = 
            if (ctx.expression().LABEL() != null) {
                Label(ctx.expression().LABEL().text)
            }
            else if (ctx.expression().ATOM() != null) {
                Atom(ctx.expression().ATOM().text.replace("\"", ""))
            }
            else {
                throw Exception("Unrecognized expression")
            }
        val assignment = Assignment(label, expr)
        blockStack.peek().add(assignment)
    }
}
*/

// ====================================
// Interpreter
typealias Scope = MutableMap<String, Variant>

class Interpreter {
    var program : Program = Program()
    var ioOut : java.io.PrintStream = System.out
    var ioIn : java.io.InputStream = System.`in`

    // Our stack frame management
    //
    val stack = Stack<Scope>()
    fun pushScope() {
        stack.push(mutableMapOf())
    }
    fun lookup(name : String) : Variant {
        stack.asReversed().forEach { scope ->
            if (scope.keys.contains(name))
                return scope.get(name)!!
        }
        
        throw Exception("NUTHIN THERE CALT ${name}");
    }
    fun store(name : String, value : Variant) {
        stack.peek().put(name, value)
    }

    // Version check
    //
    fun version() : String { return "0.1" }

    // Run, interpreter, run
    //
    fun execute(code : String) {
        val lexer = lolcodeLexer(CharStreams.fromString(code))
        val tokens = CommonTokenStream(lexer)
        val parser = lolcodeParser(tokens)
        val syntaxTree : ParseTree = parser.program()
        val program = ASTVisitor().visit(syntaxTree) as Program
        run(program)
    }
    fun run(program : Program) {
        this.program = program
        run(this.program.codeBlock)
    }
    fun run(codeBlock : CodeBlock) {
        pushScope()

        for (stmt in codeBlock.statements) {
            evaluate(stmt)
        }
    }

    fun evaluate(expr : Expression) : Variant {
        return when (expr) {
            is Atom -> Variant(expr.value)
            is Label -> lookup(expr.name)
            is BinaryOp -> {
                val left = evaluate(expr.left)
                val right = evaluate(expr.right)
                val opInt : (Long, Long) -> Long = when (expr.op.name) {
                    "ADD" -> { l, r -> l + r }
                    "SUB" -> { l, r -> l - r }
                    "MUL" -> { l, r -> l * r }
                    "DIV" -> { l, r -> l / r }
                    "MOD" -> { l, r -> l % r }
                    else -> throw Exception("Implementation error: Unrecognized operator: ${expr.op}")
                }
                val opDbl : (Double, Double) -> Double = when (expr.op.name) {
                    "ADD" -> { l, r -> l + r }
                    "SUB" -> { l, r -> l - r }
                    "MUL" -> { l, r -> l * r }
                    "DIV" -> { l, r -> l / r }
                    "MOD" -> { l, r -> l % r }
                    else -> throw Exception("Implementation error: Unrecognized operator: ${expr.op}")
                }

                return if (left.isNumbr() && right.isNumbr()) 
                        Variant(opInt(left.asInt64(), right.asInt64()))
                    else if (left.isNumbar() || right.isNumbar())
                        Variant(opDbl(left.asDouble(), right.asDouble())) 
                    else if (left.isYarn() || right.isYarn() && 
                        left.canConvertNumbr() && right.canConvertNumbr())
                        Variant(opInt(left.asInt64(), right.asInt64()))
                    else if (left.isYarn() || right.isYarn() &&
                        left.canConvertNumbar() && right.canConvertNumbar())
                        Variant(opDbl(left.asDouble(), right.asDouble())) 
                    else
                        throw Exception("CANT MATH ON WHATEVR")
            }
            else ->
                throw Exception("Unrecognized expression: ${expr}")
        }
    }

    fun evaluate(stmt : Statement) {
        when (stmt) {
            is Declaration -> {
                store(stmt.name, evaluate(stmt.expr))
            }
            is Print -> {
                var message = stmt.expressions.joinToString(prefix="", postfix="", separator="") { 
                    // print_blocks can only have expressions,
                    // so this should always be a safe cast
                    print("PRINTING ${evaluate(it).asString()}")
                    evaluate(it).asString()
                }
                ioOut.println(message)
            }
            is Input -> {
                var input = ioIn.bufferedReader().readLine()
                store(stmt.label, Variant(input))
            }
            is Assignment -> {
                store(stmt.label, evaluate(stmt.expr))
            }
            is Expression -> {
                val _unused : Variant = evaluate(stmt)
            }
        }
    }
}
